
import {printUserDefinedItems, getShowValues, createUserTypes, makeSimpleVariable, toStringObj, makeArrays, generateTypes, generateRandomValues} from './helpers/state';
import {TypeName, Variable, getBytes} from '../src/artifacts/variables';
import {removeHexPrefix} from '../src/utils';

import {shuffle, range} from './helpers/utils';

import {run} from './memory';
import test from 'ava';

const createMemoryVariable = (name: string, type: TypeName): Variable => ({
    id: -1,
    name: name,
    location: 'memory', // actually not necessary
    type: type,
    scope: -1,
    state: true,
    bytes: getBytes(type),
});

// write some dont starts the variables, just write the values
// so that we can make recursive calls to writesome
// i.e. one struct creates an array
function writeSome(name: string, type: TypeName, value: any) {
    switch (type.name) {
        case 'array':
            return value.map((v, indx) => `${name}[${indx}] = ${v};`).join('\n')
        case 'struct':
            return (type.members as Variable[]).map(v => writeSome(`${name}.${v.name}`, v.type, value[v.name])).join('\n')
        case 'enum':
            return `${name} = ${type.refName}.${value};`
        case 'string':
            return `${name} = "${value}";`
        case 'bytes':
            return `${name} = hex"${removeHexPrefix(value)}";`
        default:
            return `${name} = ${value};`
    }
}

// maybe just do that part for all of them.
function writeVariable(variable: Variable, value: any) {
    const {type, name} = variable;

    switch (type.name) {
        case 'string':
        case 'bytes':
            return `
                ${type.name} memory ${name};
                ${writeSome(name, type, value)}
            `
        case 'array':
            const base = type.base as TypeName;
            return `
                ${base.name}[] memory ${name} = new ${base.name}[](${value.length});
                ${writeSome(name, type, value)}
            `
        case 'struct':
            return `
                ${variable.type.refName as string} memory ${name};
                ${writeSome(name, type, toStringObj(getShowValues(value)))}
            `
        default:
            throw Error(`Value not found ${type.name}`)
    }
}

for (let i=0; i<100; i++) {
    test(`memory_random_${i}`, async t => {
        await generate(t);
    });
}

async function generate(t) {
    const userTypes = createUserTypes(5);

    // Create variable types

    const avoid = [
        'int',
        'intx',
        'uint',
        'uintx',
        'address',
        'byte',
        'bytesx'
    ]
    
    let types: TypeName[] = shuffle([
        ...range(0, 2).map(i => makeSimpleVariable(userTypes, avoid)),
        ...generateTypes(2, makeArrays, userTypes),
    ])

    // Remove enum variables
    types = types.filter(type => type.name != 'enum');

    // console.log(types)

    // create variables to have a name reference

    const variables = types.map((type, i) => createMemoryVariable(`val${i++}`, type));

    // console.log(JSON.stringify(variables, null, 4))

    // create the results as the variable with a random value

    let values: {[name: string]: any} = {}
    let funcStr: string[] = [];
    for (const variable of variables) {
        const value = await generateRandomValues(variable.type);

        values[variable.name] = value;
        funcStr.push(writeVariable(variable, value))
    }

    let userTypesStr = printUserDefinedItems(userTypes)

    const sample = `pragma solidity ^0.4.22;

contract Sample {
    ${userTypesStr}

    function apply() {
        ${funcStr.join('\n')}

        int dummy = 0;
    }
}
`

    const retrieved = await run(sample)

    // values generated by random program
    const cmp1 = toStringObj(getShowValues(values));

    // values retrieved
    const cmp2 = toStringObj(retrieved);
    
    t.deepEqual(cmp1, cmp2)
}
